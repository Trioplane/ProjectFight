from bolt_expressions import Scoreboard
from projectfight:player/movement import KNOCKBACK_PUSH_VECTOR_ENTITY
from ./generic_throwable import ItemGenericThrowable

velocity = {
    horizontal: Scoreboard("projectfight.items.velocity.horizontal"),
    vertical: Scoreboard("projectfight.items.velocity.vertical"),
    sideward: Scoreboard("projectfight.items.velocity.sideward"),
}

function ~/find_ground_up:
    execute if block ~ ~ ~ #air run return run tp @s ~ ~0.05 ~ ~ 0
    execute positioned ~ ~0.1 ~ run function ~/../find_ground_up

function ~/find_ground_down:
    execute unless block ~ ~ ~ #air run return run tp @s ~ ~0.1 ~ ~ 0
    execute positioned ~ ~-0.1 ~ run function ~/../find_ground_down

class ItemGenericPlaceable(ItemGenericThrowable):
    def __init__(
        self, 
        item_name, 
        config,
        damage_type = None,
        insert_on_use = None, 
        insert_on_movement_step = None, 
        insert_on_impact = None, 
        insert_on_place = None, 
        insert_on_activate = None
    ):
        super().__init__(item_name, config, damage_type, insert_on_use, insert_on_movement_step, insert_on_impact)
        self.insert_on_place = insert_on_place
        self.insert_on_activate = insert_on_activate

    def use(self):
        tag @s add projectfight.player.items.temp.owner

        execute anchored eyes at @s: 
            summon marker ^ ^ ^5 {Tags:["projectfight.utils.temp"]}
            summon item_display ^ ^ ^1 {
                Tags: [f"projectfight.items.{self.item_name}", "projectfight.items", "projectfight.items.temp",],
                item: { id: "popped_chorus_fruit", components: { item_model: f"projectfight:items/{self.item_name}" } },
                transformation: {
                    translation: [0f,0.5f,0f],
                    scale: [1f,1f,1f],
                    left_rotation: [0f,0f,0f,1f],
                    right_rotation: [0f,0f,0f,1f]
                },
                teleport_duration: 2
            }

        execute as @n[type=item_display,tag=projectfight.items.temp]: 
            rotate @s facing entity @n[type=marker,tag=projectfight.utils.temp]

            scoreboard players set @s projectfight.items.velocity.horizontal self.config.init_velocity.horizontal
            scoreboard players set @s projectfight.items.velocity.vertical self.config.init_velocity.vertical
            scoreboard players set @s projectfight.items.velocity.sideward self.config.init_velocity.sideward
            if self.config.trigger.delay > 0:
                scoreboard players set @s projectfight.items.trigger_delay self.config.trigger.delay

            function projectfight:items/main/give_id
            scoreboard players operation @s projectfight.items.owner = @p[tag=projectfight.player.items.temp.owner] projectfight.player.id

        summon item_display 0 0 0 {Tags:["projectfight.items.initial_rotation","projectfight.items.initial_rotation.temp"]}
        execute as @n[type=item_display,tag=projectfight.items.initial_rotation.temp]:
            execute rotated as @n[type=item_display,tag=projectfight.items.temp] run rotate @s ~ ~
            scoreboard players operation @s projectfight.items.owner = @n[type=item_display,tag=projectfight.items.temp] projectfight.items.id
            tag @s remove projectfight.items.initial_rotation.temp

        if self.insert_on_use: 
            self.insert_on_use(self)

        kill @n[type=marker,tag=projectfight.utils.temp]
        tag @n[type=item_display,tag=projectfight.items.temp] remove projectfight.items.temp
        tag @s remove projectfight.player.items.temp.owner

    def movement_step(self):
        execute unless entity @s[tag=f"projectfight.items.{self.item_name}.placed"] run return:
            execute at @s if function projectfight:items/collision/check/ground run return:
                tag @s add f"projectfight.items.{self.item_name}.placed"
                tag @s add f"projectfight.items.{self.item_name}.placed.temp"

                execute:
                    execute unless block ~ ~ ~ #air run return run function projectfight:items/definitions/generic_placeable/find_ground_up
                    function projectfight:items/definitions/generic_placeable/find_ground_down

                # TODO: find the exact formula on how to get the display size to match with distance check
                #       ...or maybe use dx dy dz

                summon item_display ~ ~ ~ {
                    Tags:[f"projectfight.items.{self.item_name}.trigger_area", f"projectfight.items.{self.item_name}.trigger_area.temp"],
                    brightness: {block: 15, sky: 15},
                    item: { id: "popped_chorus_fruit", components: { item_model: "projectfight:general/trigger_area" } },
                    transformation: {
                       translation: [0f,0.51f,0f],
                       scale: [(self.config.trigger.range),1f,(self.config.trigger.range)],
                       left_rotation: [0f,0f,0f,1f],
                       right_rotation: [0f,0f,0f,1f]
                    }
                }
                execute as @n[type=item_display,tag=f"projectfight.items.{self.item_name}.trigger_area.temp"]:
                    ride @s mount @n[type=item_display,tag=f"projectfight.items.{self.item_name}.placed.temp"]
                    data modify entity @s Rotation set from entity @n[type=item_display,tag=f"projectfight.items.{self.item_name}.placed.temp"]
                    tag @s remove f"projectfight.items.{self.item_name}.trigger_area.temp"

                if self.insert_on_place: 
                    self.insert_on_place(self)

                tag @s remove f"projectfight.items.{self.item_name}.placed.temp"

            if self.insert_on_movement_step: 
                self.insert_on_movement_step(self)

            execute at @s:
                execute if function projectfight:items/collision/check/block_ahead run return:
                    # awful bounce logic
                    velocity.horizontal["@s"] = velocity.horizontal["@s"] * -0.2

                    execute store result storage projectfight:items temp.item.velocity.horizontal float 0.001 run scoreboard players get @s projectfight.items.velocity.horizontal
                    execute store result storage projectfight:items temp.item.velocity.vertical float 0.001 run scoreboard players get @s projectfight.items.velocity.vertical

                # no wall
                execute store result storage projectfight:items temp.item.velocity.horizontal float 0.001 run scoreboard players get @s projectfight.items.velocity.horizontal
                execute store result storage projectfight:items temp.item.velocity.vertical float 0.001 run scoreboard players get @s projectfight.items.velocity.vertical
                execute store result storage projectfight:items temp.item.velocity.sideward float 0.001 run scoreboard players get @s projectfight.items.velocity.sideward
    
            function projectfight:items/movement/move/gravity with storage projectfight:items temp.item.velocity
    
            execute if score @s projectfight.items.velocity.horizontal matches -10..10:
                velocity.horizontal["@s"] = 0

            # awful bounce logic
            execute if score @s projectfight.items.velocity.horizontal matches 1..:
                if self.config.acceleration.horizontal < 0:
                    velocity.horizontal["@s"] -= (self.config.acceleration.horizontal * -1)
                else:
                    velocity.horizontal["@s"] += self.config.acceleration.horizontal
            
            execute if score @s projectfight.items.velocity.horizontal matches ..-1:
                if self.config.acceleration.horizontal < 0:
                    velocity.horizontal["@s"] += self.config.acceleration.horizontal
                else:
                    velocity.horizontal["@s"] -= (self.config.acceleration.horizontal * -1)
        
            execute unless score @s projectfight.items.velocity.vertical matches ..-2000:
                if self.config.acceleration.vertical < 0:
                    velocity.vertical["@s"] -= (self.config.acceleration.vertical * -1)
                else:
                    velocity.vertical["@s"] += self.config.acceleration.vertical
    
            if self.config.acceleration.sideward < 0:
                velocity.vertical["@s"] -= (self.config.acceleration.sideward * -1)
            else:
                velocity.vertical["@s"] += self.config.acceleration.sideward
        # end of return

        trigger_range = self.config.trigger.range - 1
        trigger_offset = trigger_range / -2

        if self.config.trigger.delay > 0:
            execute if entity @s[tag=f"projectfight.items.{self.item_name}.activated"] run return:
                execute if score @s projectfight.items.trigger_delay matches 1.. run scoreboard players remove @s projectfight.items.trigger_delay 1
                execute if score @s projectfight.items.trigger_delay matches 0 run function f"projectfight:items/definitions/{self.item_name}/on_impact"

            execute 
                align xyz 
                positioned ~trigger_offset ~ ~trigger_offset
                if entity @a[
                    tag=!projectfight.player.dead,
                    dx=(trigger_range),
                    dy=0,
                    dz=(trigger_range),
                ]:
                if self.insert_on_activate: 
                    self.insert_on_activate(self)
                tag @s add f"projectfight.items.{self.item_name}.activated"
        else:
            execute 
                align xyz 
                positioned ~trigger_offset ~ ~trigger_offset 
                if entity @a[
                    tag=!projectfight.player.dead,
                    dx=(self.config.trigger.range),
                    dy=0,
                    dz=(self.config.trigger.range),
                ]:
                if self.insert_on_activate: 
                    self.insert_on_activate(self)
                function f"projectfight:items/definitions/{self.item_name}/on_impact"
    
    def on_impact(self):
        tag @s add projectfight.items.temp.impact
        execute as @a if score @s projectfight.player.id = @n[type=item_display,tag=projectfight.items.temp.impact] projectfight.items.owner:
            tag @s add projectfight.player.temp.attacker

        aoe_range = self.config.on_impact.aoe_range - 1
        aoe_range_offset = aoe_range / -2
        aoe_range_offset_back = aoe_range_offset * -1
        aoe_range_y = aoe_range * 0.4

        execute
            align xyz
            positioned ~aoe_range_offset ~ ~aoe_range_offset
            as @a[
                tag=!projectfight.player.dead,
                dx=aoe_range,
                dy=aoe_range_y,
                dz=aoe_range
            ]
            positioned ~aoe_range_offset_back ~ ~aoe_range_offset_back:
            tag @s add projectfight.player.temp.victim
            scoreboard players add @s projectfight.player.damage_to_deal self.config.on_impact.damage
            execute
                facing entity @s eyes 
                positioned 0.0 0.0 0.0 
                run tp KNOCKBACK_PUSH_VECTOR_ENTITY ^ ^ ^self.config.on_impact.knockback_strength ~ ~
            function projectfight:player/movement/knockback/apply

        # uncomment when needed
        #data modify storage projectfight:health temp.damage.type set value self.damage_type
        data modify storage projectfight:health temp.damage.translation_key set value f"projectfight.death.{self.damage_type}"
        function projectfight:player/health/apply_damage

        if self.insert_on_impact:
            self.insert_on_impact(self)

        execute on passengers run kill @s
    
        execute as @e[type=item_display,tag=projectfight.items.initial_rotation] if score @s projectfight.items.owner = @n[type=item_display,tag=projectfight.items.temp.impact] projectfight.items.id:
            kill @s
    
        kill @s


# ItemGenericPlaceable("generic_placeable", {
#     init_velocity: {
#         horizontal: 600,
#         vertical: 0,
#         sideward: 0
#     },
#     acceleration: {
#         horizontal: 0,
#         vertical: -70,
#         sideward: 0
#     },
#     on_impact: {
#         aoe_range: 5,
#         knockback_strength: 40,
#         damage: 70
#     },
#     trigger: {
#         range: 2,
#         delay: 20
#     }
# }).build()