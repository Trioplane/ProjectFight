from bolt_expressions import Scoreboard, Data
from ./generic_throwable import ItemGenericThrowable

velocity = {
    horizontal: Scoreboard("projectfight.items.velocity.horizontal"),
    vertical: Scoreboard("projectfight.items.velocity.vertical"),
    sideward: Scoreboard("projectfight.items.velocity.sideward"),
}

rot_x = Scoreboard("projectfight.items.rot.x")

class ItemGenericThrowableBouncy(ItemGenericThrowable):
    def __init__(self, item_name, config, damage_type = None, insert_on_use = None, insert_on_movement_step = None, insert_on_impact = None):
        super().__init__(item_name, config, damage_type, insert_on_use, insert_on_movement_step, insert_on_impact)

    # THIS IS NOT HOW YOU SHOULD DO BOUNCE, THIS IS TEMPORARY
    # ALL THIS DOES IS KEEP FLIPPING THE SIGN OF HORIZONTAL VEL WHEN HITTING A WALl
    # WHEN IN REALITY, IT SHOULD NOT AND JUST MAKE THE ITEM CHANGE ROTATION
    # bounce_rot_x = (180 - rot_x) % 360 (when facing north/south)
    # bounce_rot_x = (-rot_x) % 360 (when facing east/west)
    # bounce_rot_y = (-rot_y) % 360 (when facing up/down)
    # idfk how to know the normals of the walls
    def movement_step(self):
        execute at @s if function projectfight:items/collision/check/ground run return run function f"projectfight:items/definitions/{self.item_name}/on_impact"

        if self.insert_on_movement_step: 
            self.insert_on_movement_step(self)

        execute at @s:
            execute if function projectfight:items/collision/check/block_ahead run return:
                rot_x["@s"] = Data.entity("@s").Rotation[0]
                rot_x["@s"] = (180 - rot_x["@s"]) % 360
                scoreboard players operation #compare_value projectfight.predicate.compare_score = @s projectfight.items.id
                execute store result entity @e[type=item_display,tag=projectfight.items.initial_rotation,predicate=projectfight:util/compare_score/items.owner,limit=1] Rotation[0] float 1 run scoreboard players get @s projectfight.items.rot.x
                tellraw @a "wall!"

            # no wall
            execute store result storage projectfight:items temp.item.velocity.horizontal float 0.001 run scoreboard players get @s projectfight.items.velocity.horizontal
            execute store result storage projectfight:items temp.item.velocity.vertical float 0.001 run scoreboard players get @s projectfight.items.velocity.vertical
            execute store result storage projectfight:items temp.item.velocity.sideward float 0.001 run scoreboard players get @s projectfight.items.velocity.sideward
            tellraw @a "no wall :("

        function projectfight:items/movement/move/gravity with storage projectfight:items temp.item.velocity

        execute if score @s projectfight.items.velocity.horizontal matches 0..:
            if self.config.acceleration.horizontal < 0:
                velocity.horizontal["@s"] -= (self.config.acceleration.horizontal * -1)
            else:
                velocity.horizontal["@s"] += self.config.acceleration.horizontal
    
        execute unless score @s projectfight.items.velocity.vertical matches ..-2000:
            if self.config.acceleration.vertical < 0:
                velocity.vertical["@s"] -= (self.config.acceleration.vertical * -1)
            else:
                velocity.vertical["@s"] += self.config.acceleration.vertical

        if self.config.acceleration.sideward < 0:
            velocity.vertical["@s"] -= (self.config.acceleration.sideward * -1)
        else:
            velocity.vertical["@s"] += self.config.acceleration.sideward


# ItemGenericThrowableBouncy("generic_throwable_bouncy", {
#     init_velocity: {
#         horizontal: 1000,
#         vertical: 0,
#         sideward: 0
#     },
#     acceleration: {
#         horizontal: 0,
#         vertical: -30,
#         sideward: 0
#     },
#     on_impact: {
#         aoe_range: 4,
#         knockback_strength: 20,
#         damage: 30
#     }
# }).build()